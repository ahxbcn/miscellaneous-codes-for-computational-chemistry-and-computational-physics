"""
Generate CIF file (<v2.0) which can be easily read by
many other programs from vesta file instead of parsing
provided mcif file. Only cell parameters, symmetry operations
and unique atom positions are obtained, but it is enough
for generating STRU file for ABACUS.

Hong Zhu
2025/03/11
"""
from pathlib import Path
from fractions import Fraction

def get_content_line_num(vesta_file_content: list, content: str) -> int:
    """
    Get the line number containing given string in the original
    .vesta file. Notice that only the first line containing the
    given string will be found.
    """
    for index, line_content in enumerate(vesta_file_content):
        if content in line_content:
            return index

    print(f"{content} not found for given vesta file!")
    return 0

def get_cif_sym_opt_line(vesta_sym_op: str) -> str:
    """
    Parse symmetry operation in vesta file and transform it
    into appearance in CIF file
    """

    def get_direction(vector: list) -> str:
        if vector[0] == 1:
            return 'x'
        elif vector[0] == -1:
            return '-x'
        elif vector[1] == 1:
            return 'y'
        elif vector[1] == -1:
            return '-y'
        elif vector[2] == 1:
            return 'z'
        elif vector[2] == -1:
            return '-z'
        else:
            print(vector)
            raise NotImplementedError

    def get_displacement(disp: float) -> str:
        fraction = Fraction(disp).limit_denominator(10)
        if fraction.numerator == 0:
            disp_str = ''
        elif fraction.numerator > 0:
            disp_str = f"+{fraction.numerator}/{fraction.denominator}"
        else:
            disp_str = f"{fraction.numerator}/{fraction.denominator}"
        return disp_str

    def get_symm_component(disp: float, vector: list) -> str:
        disp_i = get_displacement(disp)
        direc_i = get_direction(vector)
        symm_component = direc_i + disp_i
        return symm_component

    vesta_sym_op = vesta_sym_op.split()
    disps = vesta_sym_op[:3]
    vectors = vesta_sym_op[3:12]
    for index, disp in enumerate(disps):
        disps[index] = float(disp)
    for index, vector_i in enumerate(vectors):
        try:
            vectors[index] = int(vector_i)
        except ValueError:
            vectors[index] = round(float(vector_i))
    vector_a, vector_b, vector_c = vectors[:3], vectors[3:6], vectors[6:]

    symm_comp_x = get_symm_component(disps[0], vector_a)
    symm_comp_y = get_symm_component(disps[1], vector_b)
    symm_comp_z = get_symm_component(disps[2], vector_c)
    symm_opt_line = "'" + symm_comp_x + ', ' + symm_comp_y + ', ' + symm_comp_z + "'"

    return symm_opt_line

def transform_vesta_to_cif(vesta_file: str):
    """
    Generate simple readable CIF file from vesta file
    """
    print(vesta_file)
    # The specific file is generated by VESTA 2, and is leaved for processing manually
    if "1.51.Cs2CoCl4.vesta" in vesta_file:
        print("Please tranform this file manually")
        return False

    vesta_file_content = []
    with open(vesta_file, encoding='UTF-8') as fin:
        for lines in fin:
            vesta_file_content.append(lines)

    # Obtain chemical name
    chemical_name_line = get_content_line_num(vesta_file_content, "TITLE") + 1
    chemical_name = vesta_file_content[chemical_name_line].strip()

    # Obtain space group name and corresponding IT number
    space_group_line = get_content_line_num(vesta_file_content, "GROUP") + 1
    space_group_info = vesta_file_content[space_group_line].split()
    if len(space_group_info) == 3:
        internation_number = int(space_group_info[0])
        space_group_name   = space_group_info[2]
    elif len(space_group_info) >= 4:
        # Try to convert splitted space group identifiers
        internation_number = int(space_group_info[0])
        space_group_name   = ''.join(space_group_info[2:])
    else:
        print("Space group info: ", space_group_info)
        raise NotImplementedError

    # Obtain cell parameters
    cell_parameters = {}
    cell_param_line = get_content_line_num(vesta_file_content, "CELLP") + 1

    cell_param_line_content = vesta_file_content[cell_param_line].split()
    for index, value in enumerate(cell_param_line_content):
        cell_param_line_content[index] = float(value)

    cell_parameters = {'a': cell_param_line_content[0],
                       'b': cell_param_line_content[1],
                       'c': cell_param_line_content[2],
                       'alpha': cell_param_line_content[3],
                       'beta':  cell_param_line_content[4],
                       'gamma': cell_param_line_content[5]}

    # Obtain symmetry operations
    sym_op_start_line = get_content_line_num(vesta_file_content, "SYMOP") + 1
    sym_op_end_line   = get_content_line_num(vesta_file_content, "TRANM") - 1
    sym_opt_lines = []
    for line in vesta_file_content[sym_op_start_line:sym_op_end_line]:
        sym_opt_lines.append(get_cif_sym_opt_line(line))

    # Obtain unique atom positions and kinds
    atom_sites = []
    atom_posi_kind_start = get_content_line_num(vesta_file_content, "STRUC") + 1
    atom_posi_kind_end   = get_content_line_num(vesta_file_content, "THERI") - 1
    for line in vesta_file_content[atom_posi_kind_start:atom_posi_kind_end:2]:
        words = line.split()
        label = words[2]
        occupancy = float(words[3])
        fract_x = float(words[4])
        fract_y = float(words[5])
        fract_z = float(words[6])
        type_symbol = words[1]
        wyckoff = words[7]

        atom_sites.append([label, occupancy, fract_x, fract_y, fract_z, 'Uiso', '?', type_symbol])

    # Write CIF file from obtained data
    split_index = vesta_file.rindex(".")
    out_cif_name = vesta_file[:split_index] + ".cif"
    with open(out_cif_name, "w", encoding="UTF-8") as fout:
        fout.write("""
#======================================================================
# CRYSTAL DATA
#----------------------------------------------------------------------
data_VESTA_phase_1

""")
        fout.write("%-40s %s\n" % ("_chemical_name_common", chemical_name))
        fout.write("%-40s %f\n" % ("_cell_length_a", cell_parameters['a']))
        fout.write("%-40s %f\n" % ("_cell_length_b", cell_parameters['b']))
        fout.write("%-40s %f\n" % ("_cell_length_c", cell_parameters['c']))
        fout.write("%-40s %f\n" % ("_cell_length_alpha", cell_parameters['alpha']))
        fout.write("%-40s %f\n" % ("_cell_angle_beta", cell_parameters['beta']))
        fout.write("%-40s %f\n" % ("_cell_angle_gamma", cell_parameters['gamma']))
        fout.write("%-40s %f\n" % ("_cell_angle_alpha", cell_parameters['alpha']))
        fout.write("%-40s %s\n" % ("_space_group_name_H-M_alt", "'"+space_group_name+"'"))
        fout.write("%-40s %d\n" % ("_space_group_IT_number", internation_number))

        fout.write("\nloop_\n_space_group_symop_operation_xyz\n")
        for sym_opt_line in sym_opt_lines:
            fout.write(f"   {sym_opt_line}\n")

        fout.write("""\nloop_
   _atom_site_label
   _atom_site_occupancy
   _atom_site_fract_x
   _atom_site_fract_y
   _atom_site_fract_z
   _atom_site_adp_type
   _atom_site_U_iso_or_equiv
   _atom_site_type_symbol
""")
        for atom_site in atom_sites:
            label, occupancy, fract_x, fract_y, fract_z, _, _, type_symbol = atom_site
            print_line = f"   {label:10s}{occupancy:8f}{fract_x:13f}{fract_y:13f}{fract_z:13f}" + \
                         f"    Uiso  ? {type_symbol}\n"
            fout.write(print_line)
        fout.write("\n")

    return True

num_transformed_str = 0
materials = [item.name for item in Path("./dbfiles").iterdir() if item.is_dir()]
for material in materials:
    material_path = './dbfiles/' + material
    material_vesta_files = [item.name for item in Path(material_path).iterdir()
                            if item.is_file() and item.suffix == '.vesta']

    print(material)
    if len(material_vesta_files) == 2:
        if material_vesta_files[0].endswith("_M.vesta"):
            material_vesta_file = './dbfiles/' + material + '/' + material_vesta_files[1]
        else:
            material_vesta_file = './dbfiles/' + material + '/' + material_vesta_files[0]

        num_transformed_str += transform_vesta_to_cif(material_vesta_file)

    elif len(material_vesta_files) == 1:
        if material_vesta_files[0].endswith("_M.vesta"):
            print(f"Warning! Only vesta file with just magnetic atoms is avaliable for {material}")
            material_vesta_file = './dbfiles/' + material + '/' + material_vesta_files[0]

        num_transformed_str += transform_vesta_to_cif(material_vesta_file)

    elif len(material_vesta_files) == 0:
        print(f"Warning! No vesta file avaliable for {material}")

print(f"Successfully transformed structure for {num_transformed_str} materials!")
